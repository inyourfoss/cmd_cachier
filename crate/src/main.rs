
mod socket {
    pub fn dir() -> String {
        let os : &str = std::env::consts::OS;
        let runtime_dir : String = match os {
            "linux" => std::env::var("XDG_RUNTIME_DIR").expect("XDG_RUNTIME_DIR is not set."),
            "macos" => format!("{}/Library/Application Support",
                               std::env::var("HOME").expect("HOMEDIR Is not set.")
                              ),
            _ => panic!("Could not determine platform.")
        };

        format!("{runtime_dir}/cmd_cachier_redis.sock")
    }

    pub fn unix() -> String {
        format!("unix://{}", dir())
    }
}


mod constants {
    // Solution found: https://stackoverflow.com/questions/27840394/how-can-a-rust-program-access-metadata-from-its-cargo-package
    pub const VERSION: Option<&str> = option_env!("CARGO_PKG_VERSION"); 
    pub const REDIS_READ_WRITE_LATENCY_IN_MS: std::time::Duration = std::time::Duration::from_millis(20); // needs to be adjusted on weak hardware

    // Define the string to pass as stdin
    pub fn  config_string() -> String{
        return format!( r#"
            port 0
            daemonize yes
            unixsocket '{}'
            unixsocketperm 700
            save ""
            appendonly no
            "#, crate::socket::dir());
    } 
}

mod database {

    pub fn connection() -> redis::Connection {
        let client: redis::Client = redis::Client::open(crate::socket::unix()).expect("Error: Socket not found");
        return client.get_connection().expect("Could not establish connection. When querying");
    }

}

mod cli_args {
    use std::env;

    pub fn sub_cmd() -> String {
        match env::args().nth(1) {
            Some(a) => a,
            None => "none".to_string(),
        }
    }

    pub fn cli_cmd(has_subcommand: bool) -> Vec<String> {
        let mut offset: u8 = 1;

        if has_subcommand {
            offset += 1;
        }

        env::args().skip(offset.into()).collect()
    }
}

mod server {
    use std::process::{Stdio, Command};

    // Magically needed for stdin.write_all() and so on.
    use std::io::{Read, Write};

    pub fn start() -> bool {

        if is_running() {
            return true
        } else {
            eprintln!("Server is not running yet. Starting server...");
        }

        let config_string = crate::constants::config_string();

        // Rest of function mostly generated by LLM. Seems to work well but will refactor later.

        let mut cmd = Command::new("redis-server")
            .arg("-")
            .stdin(Stdio::piped()) 
            .stdout(Stdio::piped()) 
            .spawn()
            .expect("Failed to start the server.");

        // Get a handle to stdin of the child process
        let stdin = cmd.stdin.as_mut().expect("Failed to open stdin");


        // Write the config string to the child process's stdin
        stdin.write_all(config_string.as_bytes()).expect("Failed to write to stdin");


        // Wait for the child process to finish
        let status = cmd.wait().expect("Failed to wait for command");

        // Write to stdout_buffer
        let mut stdout_buffer = Vec::new();
        let stdout = cmd.stdout.as_mut().expect("Failed to open stdout");
        stdout.read_to_end(&mut stdout_buffer).expect("Failed to read stdout");


        eprintln!("{}", String::from_utf8_lossy(&stdout_buffer));

        // Check if the command was successful
        if status.success() {
            eprintln!("Started server successfully.");
        } else {
            eprintln!("Server failed with: {:?}", status.code());
        }

        while ! (is_running()){
            eprint!("\rWaiting to connect to server...");
            std::thread::sleep(crate::constants::REDIS_READ_WRITE_LATENCY_IN_MS);
        }
        eprintln!();

        true
    }

    fn is_running() -> bool {

        let dbg_socket :String = crate::socket::unix();

        let error_message :String = format!("Connection string might be wrong.{dbg_socket}");

        let client = redis::Client::open(crate::socket::unix()).expect(&error_message);


        client.get_connection().is_ok() as bool
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    use cache_commands::*;

    server::start();

    let version = constants::VERSION.unwrap_or("unknown");

    match cli_args::sub_cmd().as_str() {
        // 'save' can explicitly save 
        // which is usefull for forcefully overwriting previous entries.
        "save" => save_cmd(cli_args::cli_cmd(true))?,
        "version" => println!("cmd_cachier version {version}"),
        "meminfo" => redis_meminfo()?,
        "help" => display_help_page()?,
        "none" => display_help_page()?,
        _ => save_or_query_cmd(cli_args::cli_cmd(false))?,
    }

    Ok(())
}

mod cache_commands {
    use std::process::Command;
    use colored::*;

    fn query_cmd(args: Vec<String>) -> Result<(), Box<dyn std::error::Error>> {

        eprintln!("Querying...");
        let mut _con = crate::database::connection();


        let joined_args:String = args.join(" ");

        let result: String = match redis::cmd("HGET").arg("cmd").arg(&joined_args).query(&mut _con) {
            Ok(a) => a,
            _ => format!("{}\n  {}\n{}\n", "KEY:".red().underline().bold(), &joined_args.bold(), "Not found in cache.".red().bold() )
        };


        print!("{}", result);

        Ok(())
    }

    pub fn save_or_query_cmd(args: Vec<String>) -> Result<(), Box<dyn std::error::Error>> {

        let mut _con = crate::database::connection();

        let joined_args:String = args.join(" ");

        let redis_result: Option<String> = redis::cmd("HGET").arg("cmd").arg(&joined_args).query(&mut _con)?;

        match redis_result {
            Some(a) => print!("{}", a),
            _ => save_cmd(args)?
        }

        Ok(())
    }


    pub fn save_cmd(args: Vec<String>) -> Result<(), Box<dyn std::error::Error>> {
        let mut _con = crate::database::connection();

        let joined_args = args.join(" ");

        let execute_command = Command::new(&args[0]).args(&args[1..])
            .output().expect("Could not execute redis-cli.");

        let cmd_stdout: String = String::from_utf8_lossy(&execute_command.stdout).to_string();

        eprintln!("{}{} writing {}{}{} to cache.", 
                  "INFO".yellow().bold().underline(), ":".yellow().bold(), 
                  "\"".yellow().bold(),
                  &joined_args.yellow().bold(),
                  "\"".yellow().bold(),
                  );

        redis::cmd("HSET").arg("cmd").arg(joined_args).arg(cmd_stdout).execute(&mut _con);

        //TODO: Implement while loop for when key is not in cache.
        std::thread::sleep(crate::constants::REDIS_READ_WRITE_LATENCY_IN_MS);

        query_cmd(args)?;

        Ok(())
    }


    pub fn redis_meminfo() -> Result<(), Box<dyn std::error::Error>> {
        let mut _con = crate::database::connection();

        let used_mem_size :f64 = redis::cmd("MEMORY").arg("USAGE").arg("cmd").query(&mut _con)?;

        let to_megabytes = |i: f64| -> String { format!("{:.3} KiB", i / (1024.0)) };
        let to_kibibytes = |i: f64| -> String { format!("{:.3} MiB", i / (1024.0 * 1024.0)) };
        let kib_mib_cutoff_in_bytes: f64 = 1000.0 * 1024.0;

        let formated_mem_usage: String = 
            if used_mem_size > kib_mib_cutoff_in_bytes {
                to_kibibytes(used_mem_size)
            } else {
                to_megabytes(used_mem_size)
            };

         println!("MEMORY USED:\n  {}", formated_mem_usage);

        Ok(())
    }

    pub fn display_help_page() -> Result<(), Box<dyn std::error::Error>> {
        //    eprintln!("{}", "Success!".green().underline().bold());
        let help_page = r#"cmd_cachier help page

    USAGE
    Basic usage (Saves automatically if command is not already in cache but otherwise prints from cache):
        $ cmd_cachier ANY_COMMAND

    Use with subcommand:
        $ cmd_cachier SUBCOMMAND [ANY_COMMAND]

    MORE HELP
    View man page:
        $ man cmd_cachier

    SUBCOMMANDS
    Force cache refresh for a command:
        $ cmd_cachier save ANY_COMMAND

    Display memory usage:
        $ cmd_cachier meminfo

    Display help page:
        $ cmd_cachier help
    "#;
        println!("{}", help_page);
        Ok(())
    }

}

